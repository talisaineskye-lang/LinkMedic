{"version":3,"sources":["turbopack:///[project]/node_modules/openid-client/package.json","../../../src/lib/link-parser.ts","../../../src/lib/link-checker.ts","../../../src/lib/scanner.ts","../../../src/app/api/scan/route.ts","../../../node_modules/next/src/build/templates/app-route.ts"],"sourcesContent":["{\"name\":\"openid-client\",\"version\":\"5.7.1\",\"description\":\"OpenID Connect Relying Party (RP, Client) implementation for Node.js runtime, supports passportjs\",\"keywords\":[\"auth\",\"authentication\",\"basic\",\"certified\",\"client\",\"connect\",\"dynamic\",\"electron\",\"hybrid\",\"identity\",\"implicit\",\"oauth\",\"oauth2\",\"oidc\",\"openid\",\"passport\",\"relying party\",\"strategy\"],\"homepage\":\"https://github.com/panva/openid-client\",\"repository\":\"panva/openid-client\",\"funding\":{\"url\":\"https://github.com/sponsors/panva\"},\"license\":\"MIT\",\"author\":\"Filip Skokan <panva.ip@gmail.com>\",\"exports\":{\"types\":\"./types/index.d.ts\",\"import\":\"./lib/index.mjs\",\"require\":\"./lib/index.js\"},\"main\":\"./lib/index.js\",\"types\":\"./types/index.d.ts\",\"files\":[\"lib\",\"types/index.d.ts\"],\"scripts\":{\"format\":\"npx prettier --loglevel silent --write ./lib ./test ./certification ./types\",\"test\":\"mocha test/**/*.test.js\"},\"dependencies\":{\"jose\":\"^4.15.9\",\"lru-cache\":\"^6.0.0\",\"object-hash\":\"^2.2.0\",\"oidc-token-hash\":\"^5.0.3\"},\"devDependencies\":{\"@types/node\":\"^16.18.106\",\"@types/passport\":\"^1.0.16\",\"base64url\":\"^3.0.1\",\"chai\":\"^4.5.0\",\"mocha\":\"^10.7.3\",\"nock\":\"^13.5.5\",\"prettier\":\"^2.8.8\",\"readable-mock-req\":\"^0.2.2\",\"sinon\":\"^9.2.4\",\"timekeeper\":\"^2.3.1\"},\"standard-version\":{\"scripts\":{\"postchangelog\":\"sed -i '' -e 's/### \\\\[/## [/g' CHANGELOG.md\"},\"types\":[{\"type\":\"feat\",\"section\":\"Features\"},{\"type\":\"fix\",\"section\":\"Fixes\"},{\"type\":\"chore\",\"hidden\":true},{\"type\":\"docs\",\"hidden\":true},{\"type\":\"style\",\"hidden\":true},{\"type\":\"refactor\",\"section\":\"Refactor\",\"hidden\":false},{\"type\":\"perf\",\"section\":\"Performance\",\"hidden\":false},{\"type\":\"test\",\"hidden\":true}]}}","export interface ParsedLink {\n  url: string;\n  merchant: \"amazon\" | \"other\";\n  asin?: string;\n}\n\n// URL regex that matches most common URL formats\nconst URL_REGEX = /https?:\\/\\/[^\\s<>\"{}|\\\\^`\\[\\]]+/gi;\n\n// Patterns to ignore (timestamps, emails, social handles)\nconst TIMESTAMP_REGEX = /^\\d{1,2}:\\d{2}(:\\d{2})?$/;\nconst EMAIL_REGEX = /^mailto:|@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$/;\n\n// Amazon URL patterns\nconst AMAZON_DOMAINS = [\n  \"amazon.com\",\n  \"amazon.co.uk\",\n  \"amazon.ca\",\n  \"amazon.de\",\n  \"amazon.fr\",\n  \"amazon.es\",\n  \"amazon.it\",\n  \"amazon.co.jp\",\n  \"amazon.com.au\",\n  \"amazon.in\",\n  \"amzn.to\",\n  \"amzn.com\",\n  \"a.co\",\n];\n\n// ASIN regex (Amazon Standard Identification Number)\nconst ASIN_REGEX = /\\/(?:dp|gp\\/product|ASIN)\\/([A-Z0-9]{10})/i;\nconst ASIN_FROM_URL_REGEX = /[?&](?:asin|ASIN)=([A-Z0-9]{10})/i;\n\n// Tracking params to remove for normalization\nconst TRACKING_PARAMS = [\n  \"utm_source\",\n  \"utm_medium\",\n  \"utm_campaign\",\n  \"utm_term\",\n  \"utm_content\",\n  \"ref\",\n  \"ref_\",\n  \"linkCode\",\n  \"linkId\",\n  \"pd_rd_i\",\n  \"pd_rd_r\",\n  \"pd_rd_w\",\n  \"pd_rd_wg\",\n  \"pf_rd_i\",\n  \"pf_rd_m\",\n  \"pf_rd_p\",\n  \"pf_rd_r\",\n  \"pf_rd_s\",\n  \"pf_rd_t\",\n  \"psc\",\n  \"smid\",\n  \"spLa\",\n  \"sr\",\n  \"th\",\n  \"fbclid\",\n  \"gclid\",\n  \"dclid\",\n];\n\n/**\n * Checks if a URL is from Amazon\n */\nfunction isAmazonUrl(url: string): boolean {\n  try {\n    const urlObj = new URL(url);\n    const hostname = urlObj.hostname.toLowerCase();\n    return AMAZON_DOMAINS.some(domain =>\n      hostname === domain || hostname.endsWith(`.${domain}`)\n    );\n  } catch {\n    return false;\n  }\n}\n\n/**\n * Extracts ASIN from an Amazon URL\n */\nfunction extractAsin(url: string): string | undefined {\n  // Try to extract from path\n  const pathMatch = url.match(ASIN_REGEX);\n  if (pathMatch) return pathMatch[1];\n\n  // Try to extract from query params\n  const queryMatch = url.match(ASIN_FROM_URL_REGEX);\n  if (queryMatch) return queryMatch[1];\n\n  return undefined;\n}\n\n/**\n * Normalizes a URL by removing tracking parameters\n */\nfunction normalizeUrl(url: string): string {\n  try {\n    const urlObj = new URL(url);\n\n    // Remove tracking params\n    TRACKING_PARAMS.forEach(param => {\n      urlObj.searchParams.delete(param);\n    });\n\n    // Clean up hash if it looks like tracking\n    if (urlObj.hash && urlObj.hash.includes(\"ref=\")) {\n      urlObj.hash = \"\";\n    }\n\n    return urlObj.toString();\n  } catch {\n    return url;\n  }\n}\n\n/**\n * Checks if a string looks like a timestamp (not a URL)\n */\nfunction isTimestamp(text: string): boolean {\n  return TIMESTAMP_REGEX.test(text);\n}\n\n/**\n * Checks if a URL should be ignored (email, social handle, etc.)\n */\nfunction shouldIgnore(url: string): boolean {\n  return EMAIL_REGEX.test(url);\n}\n\n/**\n * Extracts and parses all URLs from a video description\n * @param description - The video description text\n * @returns Array of parsed links with merchant info\n */\nexport function extractLinksFromDescription(description: string): ParsedLink[] {\n  if (!description) return [];\n\n  // Find all URLs\n  const matches = description.match(URL_REGEX) || [];\n\n  // Process and deduplicate\n  const seenUrls = new Set<string>();\n  const links: ParsedLink[] = [];\n\n  for (const rawUrl of matches) {\n    // Clean up URL (remove trailing punctuation)\n    let url = rawUrl.replace(/[.,;:!?)]+$/, \"\");\n\n    // Skip timestamps and emails\n    if (isTimestamp(url) || shouldIgnore(url)) continue;\n\n    // Normalize the URL\n    const normalizedUrl = normalizeUrl(url);\n\n    // Skip duplicates\n    if (seenUrls.has(normalizedUrl)) continue;\n    seenUrls.add(normalizedUrl);\n\n    // Determine merchant and extract ASIN if Amazon\n    const isAmazon = isAmazonUrl(normalizedUrl);\n    const asin = isAmazon ? extractAsin(normalizedUrl) : undefined;\n\n    links.push({\n      url: normalizedUrl,\n      merchant: isAmazon ? \"amazon\" : \"other\",\n      asin,\n    });\n  }\n\n  return links;\n}\n\n/**\n * Filters links to only include affiliate links (currently Amazon only)\n */\nexport function filterAffiliateLinks(links: ParsedLink[]): ParsedLink[] {\n  return links.filter(link => link.merchant === \"amazon\");\n}\n\n/**\n * Gets statistics about extracted links\n */\nexport function getLinkStats(links: ParsedLink[]): {\n  total: number;\n  amazon: number;\n  other: number;\n  withAsin: number;\n} {\n  return {\n    total: links.length,\n    amazon: links.filter(l => l.merchant === \"amazon\").length,\n    other: links.filter(l => l.merchant === \"other\").length,\n    withAsin: links.filter(l => l.asin).length,\n  };\n}\n","export type LinkStatus = \"OK\" | \"OOS\" | \"NOT_FOUND\" | \"REDIRECT\" | \"UNKNOWN\";\n\nexport interface LinkCheckResult {\n  status: LinkStatus;\n  httpStatus: number | null;\n  finalUrl: string | null;\n  availabilityStatus: string | null;\n  notes: string | null;\n}\n\n// Amazon out-of-stock indicators\nconst AMAZON_OOS_INDICATORS = [\n  \"Currently unavailable\",\n  \"Out of stock\",\n  \"We don't know when or if this item will be back\",\n  \"This item is not available\",\n  \"We don't know when or if this item will be back in stock\",\n  \"Available from these sellers\",\n  \"Sign up to be notified when this item becomes available\",\n];\n\n// Error page indicators\nconst ERROR_PAGE_INDICATORS = [\n  \"Page not found\",\n  \"404\",\n  \"Product not found\",\n  \"This page doesn't exist\",\n  \"Sorry, we couldn't find that page\",\n  \"The page you requested could not be found\",\n];\n\nconst DEFAULT_TIMEOUT = 10000; // 10 seconds\nconst MAX_RETRIES = 2;\nconst RETRY_DELAY = 1000; // 1 second\n\n/**\n * Sleeps for a specified duration\n */\nfunction sleep(ms: number): Promise<void> {\n  return new Promise(resolve => setTimeout(resolve, ms));\n}\n\n/**\n * Checks if HTML content indicates Amazon out of stock\n */\nfunction checkAmazonOOS(html: string): boolean {\n  const lowerHtml = html.toLowerCase();\n  return AMAZON_OOS_INDICATORS.some(indicator =>\n    lowerHtml.includes(indicator.toLowerCase())\n  );\n}\n\n/**\n * Checks if HTML content indicates an error page\n */\nfunction isErrorPage(html: string): boolean {\n  const lowerHtml = html.toLowerCase();\n  return ERROR_PAGE_INDICATORS.some(indicator =>\n    lowerHtml.includes(indicator.toLowerCase())\n  );\n}\n\n/**\n * Fetches a URL with timeout support\n */\nasync function fetchWithTimeout(\n  url: string,\n  options: RequestInit = {},\n  timeout: number = DEFAULT_TIMEOUT\n): Promise<Response> {\n  const controller = new AbortController();\n  const timeoutId = setTimeout(() => controller.abort(), timeout);\n\n  try {\n    const response = await fetch(url, {\n      ...options,\n      signal: controller.signal,\n      redirect: \"follow\",\n      headers: {\n        \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36\",\n        \"Accept\": \"text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\",\n        \"Accept-Language\": \"en-US,en;q=0.5\",\n        ...options.headers,\n      },\n    });\n    return response;\n  } finally {\n    clearTimeout(timeoutId);\n  }\n}\n\n/**\n * Checks a single link's health status\n * @param url - The URL to check\n * @param isAmazon - Whether this is an Amazon link (for OOS detection)\n */\nexport async function checkLink(\n  url: string,\n  isAmazon: boolean = false\n): Promise<LinkCheckResult> {\n  let lastError: Error | null = null;\n\n  for (let attempt = 0; attempt <= MAX_RETRIES; attempt++) {\n    if (attempt > 0) {\n      // Exponential backoff\n      await sleep(RETRY_DELAY * Math.pow(2, attempt - 1));\n    }\n\n    try {\n      // First try HEAD request\n      let response: Response;\n      try {\n        response = await fetchWithTimeout(url, { method: \"HEAD\" });\n      } catch {\n        // Fallback to GET if HEAD fails\n        response = await fetchWithTimeout(url, { method: \"GET\" });\n      }\n\n      const httpStatus = response.status;\n      const finalUrl = response.url;\n\n      // 404 / 410 - Not found\n      if (httpStatus === 404 || httpStatus === 410) {\n        return {\n          status: \"NOT_FOUND\",\n          httpStatus,\n          finalUrl,\n          availabilityStatus: \"broken\",\n          notes: `HTTP ${httpStatus}`,\n        };\n      }\n\n      // Other error status codes\n      if (httpStatus >= 400) {\n        return {\n          status: \"NOT_FOUND\",\n          httpStatus,\n          finalUrl,\n          availabilityStatus: \"error\",\n          notes: `HTTP ${httpStatus}`,\n        };\n      }\n\n      // For Amazon links, check for out of stock in response body\n      if (isAmazon && httpStatus === 200) {\n        // Need to do a GET request to check the body\n        const getResponse = await fetchWithTimeout(url, { method: \"GET\" });\n        const html = await getResponse.text();\n\n        // Check for error page (redirected to error)\n        if (isErrorPage(html)) {\n          return {\n            status: \"NOT_FOUND\",\n            httpStatus,\n            finalUrl: getResponse.url,\n            availabilityStatus: \"error_page\",\n            notes: \"Redirected to error page\",\n          };\n        }\n\n        // Check for out of stock\n        if (checkAmazonOOS(html)) {\n          return {\n            status: \"OOS\",\n            httpStatus,\n            finalUrl: getResponse.url,\n            availabilityStatus: \"out_of_stock\",\n            notes: \"Product appears to be out of stock\",\n          };\n        }\n      }\n\n      // Check if redirected to an error page (non-Amazon)\n      if (httpStatus >= 200 && httpStatus < 300) {\n        // Only check body for potential error pages on suspicious URLs\n        if (finalUrl !== url) {\n          const getResponse = await fetchWithTimeout(url, { method: \"GET\" });\n          const html = await getResponse.text();\n          if (isErrorPage(html)) {\n            return {\n              status: \"NOT_FOUND\",\n              httpStatus,\n              finalUrl: getResponse.url,\n              availabilityStatus: \"error_page\",\n              notes: \"Redirected to error page\",\n            };\n          }\n        }\n\n        return {\n          status: \"OK\",\n          httpStatus,\n          finalUrl,\n          availabilityStatus: \"available\",\n          notes: null,\n        };\n      }\n\n      // Redirect status (3xx) - follow was enabled so this shouldn't happen\n      if (httpStatus >= 300 && httpStatus < 400) {\n        return {\n          status: \"REDIRECT\",\n          httpStatus,\n          finalUrl,\n          availabilityStatus: \"redirect\",\n          notes: `Redirected to ${finalUrl}`,\n        };\n      }\n\n      // Success\n      return {\n        status: \"OK\",\n        httpStatus,\n        finalUrl,\n        availabilityStatus: \"available\",\n        notes: null,\n      };\n    } catch (error) {\n      lastError = error instanceof Error ? error : new Error(String(error));\n\n      // If it's the last attempt, return unknown status\n      if (attempt === MAX_RETRIES) {\n        const isTimeout = lastError.name === \"AbortError\" || lastError.message.includes(\"timeout\");\n        return {\n          status: \"UNKNOWN\",\n          httpStatus: null,\n          finalUrl: null,\n          availabilityStatus: isTimeout ? \"timeout\" : \"error\",\n          notes: isTimeout ? \"Request timed out\" : `Error: ${lastError.message}`,\n        };\n      }\n    }\n  }\n\n  // Should not reach here, but just in case\n  return {\n    status: \"UNKNOWN\",\n    httpStatus: null,\n    finalUrl: null,\n    availabilityStatus: \"error\",\n    notes: lastError?.message || \"Unknown error\",\n  };\n}\n\n/**\n * Checks multiple links with rate limiting\n * @param urls - Array of URLs to check\n * @param isAmazonMap - Map of URL to whether it's an Amazon link\n * @param delayMs - Delay between checks in milliseconds\n */\nexport async function checkLinksWithRateLimit(\n  urls: string[],\n  isAmazonMap: Map<string, boolean>,\n  delayMs: number = 500\n): Promise<Map<string, LinkCheckResult>> {\n  const results = new Map<string, LinkCheckResult>();\n\n  for (const url of urls) {\n    const isAmazon = isAmazonMap.get(url) || false;\n    const result = await checkLink(url, isAmazon);\n    results.set(url, result);\n\n    // Rate limiting\n    if (urls.indexOf(url) < urls.length - 1) {\n      await sleep(delayMs);\n    }\n  }\n\n  return results;\n}\n","import { prisma } from \"./db\";\nimport { extractLinksFromDescription, filterAffiliateLinks } from \"./link-parser\";\nimport { checkLink, LinkCheckResult } from \"./link-checker\";\n\nconst RATE_LIMIT_DELAY = 500; // 500ms between checks\n\n/**\n * Extracts and stores affiliate links from a video's description\n */\nexport async function extractAndStoreLinks(videoId: string): Promise<number> {\n  const video = await prisma.video.findUnique({\n    where: { id: videoId },\n    select: { description: true },\n  });\n\n  if (!video?.description) return 0;\n\n  // Extract links from description\n  const allLinks = extractLinksFromDescription(video.description);\n  const affiliateLinks = filterAffiliateLinks(allLinks);\n\n  // Store links (upsert to avoid duplicates)\n  let stored = 0;\n  for (const link of affiliateLinks) {\n    await prisma.affiliateLink.upsert({\n      where: {\n        id: `${videoId}_${link.url.slice(0, 100)}`, // Use composite key approximation\n      },\n      create: {\n        videoId,\n        originalUrl: link.url,\n        merchant: link.merchant,\n      },\n      update: {\n        merchant: link.merchant,\n      },\n    });\n    stored++;\n  }\n\n  return stored;\n}\n\n/**\n * Extracts links from all videos for a user\n */\nexport async function extractLinksForUser(userId: string): Promise<{ videos: number; links: number }> {\n  const videos = await prisma.video.findMany({\n    where: { userId },\n    select: { id: true, description: true },\n  });\n\n  let totalLinks = 0;\n\n  for (const video of videos) {\n    if (!video.description) continue;\n\n    const allLinks = extractLinksFromDescription(video.description);\n    const affiliateLinks = filterAffiliateLinks(allLinks);\n\n    for (const link of affiliateLinks) {\n      // Check if link already exists for this video\n      const existing = await prisma.affiliateLink.findFirst({\n        where: {\n          videoId: video.id,\n          originalUrl: link.url,\n        },\n      });\n\n      if (!existing) {\n        await prisma.affiliateLink.create({\n          data: {\n            videoId: video.id,\n            originalUrl: link.url,\n            merchant: link.merchant,\n          },\n        });\n        totalLinks++;\n      }\n    }\n  }\n\n  return { videos: videos.length, links: totalLinks };\n}\n\n/**\n * Checks a single link and stores the result\n */\nexport async function checkAndStoreLinkStatus(linkId: string): Promise<LinkCheckResult> {\n  const link = await prisma.affiliateLink.findUnique({\n    where: { id: linkId },\n    select: { originalUrl: true, merchant: true },\n  });\n\n  if (!link) {\n    throw new Error(`Link not found: ${linkId}`);\n  }\n\n  const isAmazon = link.merchant === \"amazon\";\n  const result = await checkLink(link.originalUrl, isAmazon);\n\n  // Update link status\n  await prisma.affiliateLink.update({\n    where: { id: linkId },\n    data: {\n      status: result.status,\n      lastCheckedAt: new Date(),\n    },\n  });\n\n  // Store scan result\n  await prisma.scanResult.create({\n    data: {\n      affiliateLinkId: linkId,\n      httpStatus: result.httpStatus,\n      availabilityStatus: result.availabilityStatus,\n      notes: result.notes,\n    },\n  });\n\n  return result;\n}\n\n/**\n * Scans all unchecked or stale links for a user\n * @param userId - User ID\n * @param staleThresholdDays - Links older than this many days are considered stale\n */\nexport async function scanUserLinks(\n  userId: string,\n  staleThresholdDays: number = 7\n): Promise<{ checked: number; issues: number }> {\n  const staleDate = new Date();\n  staleDate.setDate(staleDate.getDate() - staleThresholdDays);\n\n  // Get links that need checking\n  const links = await prisma.affiliateLink.findMany({\n    where: {\n      video: { userId },\n      OR: [\n        { lastCheckedAt: null },\n        { lastCheckedAt: { lt: staleDate } },\n      ],\n    },\n    select: {\n      id: true,\n      originalUrl: true,\n      merchant: true,\n    },\n    take: 100, // Limit per scan to avoid timeouts\n  });\n\n  let checked = 0;\n  let issues = 0;\n\n  for (const link of links) {\n    try {\n      const isAmazon = link.merchant === \"amazon\";\n      const result = await checkLink(link.originalUrl, isAmazon);\n\n      // Update link status\n      await prisma.affiliateLink.update({\n        where: { id: link.id },\n        data: {\n          status: result.status,\n          lastCheckedAt: new Date(),\n        },\n      });\n\n      // Store scan result\n      await prisma.scanResult.create({\n        data: {\n          affiliateLinkId: link.id,\n          httpStatus: result.httpStatus,\n          availabilityStatus: result.availabilityStatus,\n          notes: result.notes,\n        },\n      });\n\n      checked++;\n      if (result.status === \"NOT_FOUND\" || result.status === \"OOS\") {\n        issues++;\n      }\n\n      // Rate limiting\n      await new Promise(resolve => setTimeout(resolve, RATE_LIMIT_DELAY));\n    } catch (error) {\n      console.error(`Error checking link ${link.id}:`, error);\n    }\n  }\n\n  return { checked, issues };\n}\n\n/**\n * Gets scan statistics for a user\n */\nexport async function getScanStats(userId: string): Promise<{\n  totalLinks: number;\n  checkedLinks: number;\n  okLinks: number;\n  brokenLinks: number;\n  oosLinks: number;\n  unknownLinks: number;\n}> {\n  const links = await prisma.affiliateLink.findMany({\n    where: { video: { userId } },\n    select: { status: true, lastCheckedAt: true },\n  });\n\n  return {\n    totalLinks: links.length,\n    checkedLinks: links.filter(l => l.lastCheckedAt).length,\n    okLinks: links.filter(l => l.status === \"OK\").length,\n    brokenLinks: links.filter(l => l.status === \"NOT_FOUND\").length,\n    oosLinks: links.filter(l => l.status === \"OOS\").length,\n    unknownLinks: links.filter(l => l.status === \"UNKNOWN\").length,\n  };\n}\n\n/**\n * Full sync and scan for a user\n * 1. Extract links from all video descriptions\n * 2. Check all unchecked/stale links\n */\nexport async function fullSyncAndScan(userId: string): Promise<{\n  extractedLinks: number;\n  checkedLinks: number;\n  issues: number;\n}> {\n  // Step 1: Extract links\n  const { links: extractedLinks } = await extractLinksForUser(userId);\n\n  // Step 2: Scan links\n  const { checked: checkedLinks, issues } = await scanUserLinks(userId);\n\n  return {\n    extractedLinks,\n    checkedLinks,\n    issues,\n  };\n}\n","import { NextResponse } from \"next/server\";\nimport { getServerSession } from \"next-auth\";\nimport { authOptions } from \"@/lib/auth\";\nimport { scanUserLinks, getScanStats } from \"@/lib/scanner\";\n\nexport async function POST() {\n  try {\n    const session = await getServerSession(authOptions);\n\n    if (!session?.user?.id) {\n      return NextResponse.json({ error: \"Unauthorized\" }, { status: 401 });\n    }\n\n    // Run the scan\n    const { checked, issues } = await scanUserLinks(session.user.id);\n\n    // Get updated stats\n    const stats = await getScanStats(session.user.id);\n\n    return NextResponse.json({\n      success: true,\n      checked,\n      issuesFound: issues,\n      stats,\n    });\n  } catch (error) {\n    console.error(\"Error scanning links:\", error);\n    return NextResponse.json(\n      { error: \"Failed to scan links\" },\n      { status: 500 }\n    );\n  }\n}\n\nexport async function GET() {\n  try {\n    const session = await getServerSession(authOptions);\n\n    if (!session?.user?.id) {\n      return NextResponse.json({ error: \"Unauthorized\" }, { status: 401 });\n    }\n\n    const stats = await getScanStats(session.user.id);\n\n    return NextResponse.json({ stats });\n  } catch (error) {\n    console.error(\"Error getting scan stats:\", error);\n    return NextResponse.json(\n      { error: \"Failed to get scan stats\" },\n      { status: 500 }\n    );\n  }\n}\n","import {\n  AppRouteRouteModule,\n  type AppRouteRouteHandlerContext,\n  type AppRouteRouteModuleOptions,\n} from '../../server/route-modules/app-route/module.compiled'\nimport { RouteKind } from '../../server/route-kind'\nimport { patchFetch as _patchFetch } from '../../server/lib/patch-fetch'\nimport type { IncomingMessage, ServerResponse } from 'node:http'\nimport { addRequestMeta, getRequestMeta } from '../../server/request-meta'\nimport { getTracer, type Span, SpanKind } from '../../server/lib/trace/tracer'\nimport { setManifestsSingleton } from '../../server/app-render/manifests-singleton'\nimport { normalizeAppPath } from '../../shared/lib/router/utils/app-paths'\nimport { NodeNextRequest, NodeNextResponse } from '../../server/base-http/node'\nimport {\n  NextRequestAdapter,\n  signalFromNodeResponse,\n} from '../../server/web/spec-extension/adapters/next-request'\nimport { BaseServerSpan } from '../../server/lib/trace/constants'\nimport { getRevalidateReason } from '../../server/instrumentation/utils'\nimport { sendResponse } from '../../server/send-response'\nimport {\n  fromNodeOutgoingHttpHeaders,\n  toNodeOutgoingHttpHeaders,\n} from '../../server/web/utils'\nimport { getCacheControlHeader } from '../../server/lib/cache-control'\nimport { INFINITE_CACHE, NEXT_CACHE_TAGS_HEADER } from '../../lib/constants'\nimport { NoFallbackError } from '../../shared/lib/no-fallback-error.external'\nimport {\n  CachedRouteKind,\n  type ResponseCacheEntry,\n  type ResponseGenerator,\n} from '../../server/response-cache'\n\nimport * as userland from 'VAR_USERLAND'\n\n// These are injected by the loader afterwards. This is injected as a variable\n// instead of a replacement because this could also be `undefined` instead of\n// an empty string.\ndeclare const nextConfigOutput: AppRouteRouteModuleOptions['nextConfigOutput']\n\n// We inject the nextConfigOutput here so that we can use them in the route\n// module.\n// INJECT:nextConfigOutput\n\nconst routeModule = new AppRouteRouteModule({\n  definition: {\n    kind: RouteKind.APP_ROUTE,\n    page: 'VAR_DEFINITION_PAGE',\n    pathname: 'VAR_DEFINITION_PATHNAME',\n    filename: 'VAR_DEFINITION_FILENAME',\n    bundlePath: 'VAR_DEFINITION_BUNDLE_PATH',\n  },\n  distDir: process.env.__NEXT_RELATIVE_DIST_DIR || '',\n  relativeProjectDir: process.env.__NEXT_RELATIVE_PROJECT_DIR || '',\n  resolvedPagePath: 'VAR_RESOLVED_PAGE_PATH',\n  nextConfigOutput,\n  userland,\n})\n\n// Pull out the exports that we need to expose from the module. This should\n// be eliminated when we've moved the other routes to the new format. These\n// are used to hook into the route.\nconst { workAsyncStorage, workUnitAsyncStorage, serverHooks } = routeModule\n\nfunction patchFetch() {\n  return _patchFetch({\n    workAsyncStorage,\n    workUnitAsyncStorage,\n  })\n}\n\nexport {\n  routeModule,\n  workAsyncStorage,\n  workUnitAsyncStorage,\n  serverHooks,\n  patchFetch,\n}\n\nexport async function handler(\n  req: IncomingMessage,\n  res: ServerResponse,\n  ctx: {\n    waitUntil: (prom: Promise<void>) => void\n  }\n) {\n  if (routeModule.isDev) {\n    addRequestMeta(req, 'devRequestTimingInternalsEnd', process.hrtime.bigint())\n  }\n  let srcPage = 'VAR_DEFINITION_PAGE'\n\n  // turbopack doesn't normalize `/index` in the page name\n  // so we need to to process dynamic routes properly\n  // TODO: fix turbopack providing differing value from webpack\n  if (process.env.TURBOPACK) {\n    srcPage = srcPage.replace(/\\/index$/, '') || '/'\n  } else if (srcPage === '/index') {\n    // we always normalize /index specifically\n    srcPage = '/'\n  }\n  const multiZoneDraftMode = process.env\n    .__NEXT_MULTI_ZONE_DRAFT_MODE as any as boolean\n\n  const prepareResult = await routeModule.prepare(req, res, {\n    srcPage,\n    multiZoneDraftMode,\n  })\n\n  if (!prepareResult) {\n    res.statusCode = 400\n    res.end('Bad Request')\n    ctx.waitUntil?.(Promise.resolve())\n    return null\n  }\n\n  const {\n    buildId,\n    params,\n    nextConfig,\n    parsedUrl,\n    isDraftMode,\n    prerenderManifest,\n    routerServerContext,\n    isOnDemandRevalidate,\n    revalidateOnlyGenerated,\n    resolvedPathname,\n    clientReferenceManifest,\n    serverActionsManifest,\n  } = prepareResult\n\n  const normalizedSrcPage = normalizeAppPath(srcPage)\n\n  let isIsr = Boolean(\n    prerenderManifest.dynamicRoutes[normalizedSrcPage] ||\n      prerenderManifest.routes[resolvedPathname]\n  )\n\n  const render404 = async () => {\n    // TODO: should route-module itself handle rendering the 404\n    if (routerServerContext?.render404) {\n      await routerServerContext.render404(req, res, parsedUrl, false)\n    } else {\n      res.end('This page could not be found')\n    }\n    return null\n  }\n\n  if (isIsr && !isDraftMode) {\n    const isPrerendered = Boolean(prerenderManifest.routes[resolvedPathname])\n    const prerenderInfo = prerenderManifest.dynamicRoutes[normalizedSrcPage]\n\n    if (prerenderInfo) {\n      if (prerenderInfo.fallback === false && !isPrerendered) {\n        if (nextConfig.experimental.adapterPath) {\n          return await render404()\n        }\n        throw new NoFallbackError()\n      }\n    }\n  }\n\n  let cacheKey: string | null = null\n\n  if (isIsr && !routeModule.isDev && !isDraftMode) {\n    cacheKey = resolvedPathname\n    // ensure /index and / is normalized to one key\n    cacheKey = cacheKey === '/index' ? '/' : cacheKey\n  }\n\n  const supportsDynamicResponse: boolean =\n    // If we're in development, we always support dynamic HTML\n    routeModule.isDev === true ||\n    // If this is not SSG or does not have static paths, then it supports\n    // dynamic HTML.\n    !isIsr\n\n  // This is a revalidation request if the request is for a static\n  // page and it is not being resumed from a postponed render and\n  // it is not a dynamic RSC request then it is a revalidation\n  // request.\n  const isStaticGeneration = isIsr && !supportsDynamicResponse\n\n  // Before rendering (which initializes component tree modules), we have to\n  // set the reference manifests to our global store so Server Action's\n  // encryption util can access to them at the top level of the page module.\n  if (serverActionsManifest && clientReferenceManifest) {\n    setManifestsSingleton({\n      page: srcPage,\n      clientReferenceManifest,\n      serverActionsManifest,\n    })\n  }\n\n  const method = req.method || 'GET'\n  const tracer = getTracer()\n  const activeSpan = tracer.getActiveScopeSpan()\n\n  const context: AppRouteRouteHandlerContext = {\n    params,\n    prerenderManifest,\n    renderOpts: {\n      experimental: {\n        authInterrupts: Boolean(nextConfig.experimental.authInterrupts),\n      },\n      cacheComponents: Boolean(nextConfig.cacheComponents),\n      supportsDynamicResponse,\n      incrementalCache: getRequestMeta(req, 'incrementalCache'),\n      cacheLifeProfiles: nextConfig.cacheLife,\n      waitUntil: ctx.waitUntil,\n      onClose: (cb) => {\n        res.on('close', cb)\n      },\n      onAfterTaskError: undefined,\n      onInstrumentationRequestError: (\n        error,\n        _request,\n        errorContext,\n        silenceLog\n      ) =>\n        routeModule.onRequestError(\n          req,\n          error,\n          errorContext,\n          silenceLog,\n          routerServerContext\n        ),\n    },\n    sharedContext: {\n      buildId,\n    },\n  }\n  const nodeNextReq = new NodeNextRequest(req)\n  const nodeNextRes = new NodeNextResponse(res)\n\n  const nextReq = NextRequestAdapter.fromNodeNextRequest(\n    nodeNextReq,\n    signalFromNodeResponse(res)\n  )\n\n  try {\n    const invokeRouteModule = async (span?: Span) => {\n      return routeModule.handle(nextReq, context).finally(() => {\n        if (!span) return\n\n        span.setAttributes({\n          'http.status_code': res.statusCode,\n          'next.rsc': false,\n        })\n\n        const rootSpanAttributes = tracer.getRootSpanAttributes()\n        // We were unable to get attributes, probably OTEL is not enabled\n        if (!rootSpanAttributes) {\n          return\n        }\n\n        if (\n          rootSpanAttributes.get('next.span_type') !==\n          BaseServerSpan.handleRequest\n        ) {\n          console.warn(\n            `Unexpected root span type '${rootSpanAttributes.get(\n              'next.span_type'\n            )}'. Please report this Next.js issue https://github.com/vercel/next.js`\n          )\n          return\n        }\n\n        const route = rootSpanAttributes.get('next.route')\n        if (route) {\n          const name = `${method} ${route}`\n\n          span.setAttributes({\n            'next.route': route,\n            'http.route': route,\n            'next.span_name': name,\n          })\n          span.updateName(name)\n        } else {\n          span.updateName(`${method} ${srcPage}`)\n        }\n      })\n    }\n    const isMinimalMode = Boolean(\n      process.env.MINIMAL_MODE || getRequestMeta(req, 'minimalMode')\n    )\n\n    const handleResponse = async (currentSpan?: Span) => {\n      const responseGenerator: ResponseGenerator = async ({\n        previousCacheEntry,\n      }) => {\n        try {\n          if (\n            !isMinimalMode &&\n            isOnDemandRevalidate &&\n            revalidateOnlyGenerated &&\n            !previousCacheEntry\n          ) {\n            res.statusCode = 404\n            // on-demand revalidate always sets this header\n            res.setHeader('x-nextjs-cache', 'REVALIDATED')\n            res.end('This page could not be found')\n            return null\n          }\n\n          const response = await invokeRouteModule(currentSpan)\n\n          ;(req as any).fetchMetrics = (context.renderOpts as any).fetchMetrics\n          let pendingWaitUntil = context.renderOpts.pendingWaitUntil\n\n          // Attempt using provided waitUntil if available\n          // if it's not we fallback to sendResponse's handling\n          if (pendingWaitUntil) {\n            if (ctx.waitUntil) {\n              ctx.waitUntil(pendingWaitUntil)\n              pendingWaitUntil = undefined\n            }\n          }\n          const cacheTags = context.renderOpts.collectedTags\n\n          // If the request is for a static response, we can cache it so long\n          // as it's not edge.\n          if (isIsr) {\n            const blob = await response.blob()\n\n            // Copy the headers from the response.\n            const headers = toNodeOutgoingHttpHeaders(response.headers)\n\n            if (cacheTags) {\n              headers[NEXT_CACHE_TAGS_HEADER] = cacheTags\n            }\n\n            if (!headers['content-type'] && blob.type) {\n              headers['content-type'] = blob.type\n            }\n\n            const revalidate =\n              typeof context.renderOpts.collectedRevalidate === 'undefined' ||\n              context.renderOpts.collectedRevalidate >= INFINITE_CACHE\n                ? false\n                : context.renderOpts.collectedRevalidate\n\n            const expire =\n              typeof context.renderOpts.collectedExpire === 'undefined' ||\n              context.renderOpts.collectedExpire >= INFINITE_CACHE\n                ? undefined\n                : context.renderOpts.collectedExpire\n\n            // Create the cache entry for the response.\n            const cacheEntry: ResponseCacheEntry = {\n              value: {\n                kind: CachedRouteKind.APP_ROUTE,\n                status: response.status,\n                body: Buffer.from(await blob.arrayBuffer()),\n                headers,\n              },\n              cacheControl: { revalidate, expire },\n            }\n\n            return cacheEntry\n          } else {\n            // send response without caching if not ISR\n            await sendResponse(\n              nodeNextReq,\n              nodeNextRes,\n              response,\n              context.renderOpts.pendingWaitUntil\n            )\n            return null\n          }\n        } catch (err) {\n          // if this is a background revalidate we need to report\n          // the request error here as it won't be bubbled\n          if (previousCacheEntry?.isStale) {\n            const silenceLog = false\n            await routeModule.onRequestError(\n              req,\n              err,\n              {\n                routerKind: 'App Router',\n                routePath: srcPage,\n                routeType: 'route',\n                revalidateReason: getRevalidateReason({\n                  isStaticGeneration,\n                  isOnDemandRevalidate,\n                }),\n              },\n              silenceLog,\n              routerServerContext\n            )\n          }\n          throw err\n        }\n      }\n\n      const cacheEntry = await routeModule.handleResponse({\n        req,\n        nextConfig,\n        cacheKey,\n        routeKind: RouteKind.APP_ROUTE,\n        isFallback: false,\n        prerenderManifest,\n        isRoutePPREnabled: false,\n        isOnDemandRevalidate,\n        revalidateOnlyGenerated,\n        responseGenerator,\n        waitUntil: ctx.waitUntil,\n        isMinimalMode,\n      })\n\n      // we don't create a cacheEntry for ISR\n      if (!isIsr) {\n        return null\n      }\n\n      if (cacheEntry?.value?.kind !== CachedRouteKind.APP_ROUTE) {\n        throw new Error(\n          `Invariant: app-route received invalid cache entry ${cacheEntry?.value?.kind}`\n        )\n      }\n\n      if (!isMinimalMode) {\n        res.setHeader(\n          'x-nextjs-cache',\n          isOnDemandRevalidate\n            ? 'REVALIDATED'\n            : cacheEntry.isMiss\n              ? 'MISS'\n              : cacheEntry.isStale\n                ? 'STALE'\n                : 'HIT'\n        )\n      }\n\n      // Draft mode should never be cached\n      if (isDraftMode) {\n        res.setHeader(\n          'Cache-Control',\n          'private, no-cache, no-store, max-age=0, must-revalidate'\n        )\n      }\n\n      const headers = fromNodeOutgoingHttpHeaders(cacheEntry.value.headers)\n\n      if (!(isMinimalMode && isIsr)) {\n        headers.delete(NEXT_CACHE_TAGS_HEADER)\n      }\n\n      // If cache control is already set on the response we don't\n      // override it to allow users to customize it via next.config\n      if (\n        cacheEntry.cacheControl &&\n        !res.getHeader('Cache-Control') &&\n        !headers.get('Cache-Control')\n      ) {\n        headers.set(\n          'Cache-Control',\n          getCacheControlHeader(cacheEntry.cacheControl)\n        )\n      }\n\n      await sendResponse(\n        nodeNextReq,\n        nodeNextRes,\n        // @ts-expect-error - Argument of type 'Buffer<ArrayBufferLike>' is not assignable to parameter of type 'BodyInit | null | undefined'.\n        new Response(cacheEntry.value.body, {\n          headers,\n          status: cacheEntry.value.status || 200,\n        })\n      )\n      return null\n    }\n\n    // TODO: activeSpan code path is for when wrapped by\n    // next-server can be removed when this is no longer used\n    if (activeSpan) {\n      await handleResponse(activeSpan)\n    } else {\n      await tracer.withPropagatedContext(req.headers, () =>\n        tracer.trace(\n          BaseServerSpan.handleRequest,\n          {\n            spanName: `${method} ${srcPage}`,\n            kind: SpanKind.SERVER,\n            attributes: {\n              'http.method': method,\n              'http.target': req.url,\n            },\n          },\n          handleResponse\n        )\n      )\n    }\n  } catch (err) {\n    if (!(err instanceof NoFallbackError)) {\n      const silenceLog = false\n      await routeModule.onRequestError(\n        req,\n        err,\n        {\n          routerKind: 'App Router',\n          routePath: normalizedSrcPage,\n          routeType: 'route',\n          revalidateReason: getRevalidateReason({\n            isStaticGeneration,\n            isOnDemandRevalidate,\n          }),\n        },\n        silenceLog,\n        routerServerContext\n      )\n    }\n\n    // rethrow so that we can handle serving error page\n\n    // If this is during static generation, throw the error again.\n    if (isIsr) throw err\n\n    // Otherwise, send a 500 response.\n    await sendResponse(\n      nodeNextReq,\n      nodeNextRes,\n      new Response(null, { status: 500 })\n    )\n    return null\n  }\n}\n"],"names":["AppRouteRouteModule","RouteKind","patchFetch","_patchFetch","addRequestMeta","getRequestMeta","getTracer","SpanKind","setManifestsSingleton","normalizeAppPath","NodeNextRequest","NodeNextResponse","NextRequestAdapter","signalFromNodeResponse","BaseServerSpan","getRevalidateReason","sendResponse","fromNodeOutgoingHttpHeaders","toNodeOutgoingHttpHeaders","getCacheControlHeader","INFINITE_CACHE","NEXT_CACHE_TAGS_HEADER","NoFallbackError","CachedRouteKind","userland","routeModule","definition","kind","APP_ROUTE","page","pathname","filename","bundlePath","distDir","process","env","__NEXT_RELATIVE_DIST_DIR","relativeProjectDir","__NEXT_RELATIVE_PROJECT_DIR","resolvedPagePath","nextConfigOutput","workAsyncStorage","workUnitAsyncStorage","serverHooks","handler","req","res","ctx","isDev","hrtime","bigint","srcPage","TURBOPACK","replace","multiZoneDraftMode","__NEXT_MULTI_ZONE_DRAFT_MODE","prepareResult","prepare","statusCode","end","waitUntil","Promise","resolve","buildId","params","nextConfig","parsedUrl","isDraftMode","prerenderManifest","routerServerContext","isOnDemandRevalidate","revalidateOnlyGenerated","resolvedPathname","clientReferenceManifest","serverActionsManifest","normalizedSrcPage","isIsr","Boolean","dynamicRoutes","routes","render404","isPrerendered","prerenderInfo","fallback","experimental","adapterPath","cacheKey","supportsDynamicResponse","isStaticGeneration","method","tracer","activeSpan","getActiveScopeSpan","context","renderOpts","authInterrupts","cacheComponents","incrementalCache","cacheLifeProfiles","cacheLife","onClose","cb","on","onAfterTaskError","undefined","onInstrumentationRequestError","error","_request","errorContext","silenceLog","onRequestError","sharedContext","nodeNextReq","nodeNextRes","nextReq","fromNodeNextRequest","invokeRouteModule","span","handle","finally","setAttributes","rootSpanAttributes","getRootSpanAttributes","get","handleRequest","console","warn","route","name","updateName","isMinimalMode","MINIMAL_MODE","handleResponse","currentSpan","cacheEntry","responseGenerator","previousCacheEntry","setHeader","response","fetchMetrics","pendingWaitUntil","cacheTags","collectedTags","blob","headers","type","revalidate","collectedRevalidate","expire","collectedExpire","value","status","body","Buffer","from","arrayBuffer","cacheControl","err","isStale","routerKind","routePath","routeType","revalidateReason","routeKind","isFallback","isRoutePPREnabled","Error","isMiss","delete","getHeader","set","Response","withPropagatedContext","trace","spanName","SERVER","attributes","url"],"mappings":"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","ignoreList":[5]}