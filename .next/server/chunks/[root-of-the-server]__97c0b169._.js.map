{"version":3,"sources":["../../../src/lib/link-parser.ts","../../../src/lib/link-checker.ts","../../../src/lib/scanner.ts","../../../src/lib/revenue-estimator.ts"],"sourcesContent":["export interface ParsedLink {\n  url: string;\n  merchant: \"amazon\" | \"other\";\n  asin?: string;\n}\n\n// URL regex that matches most common URL formats\nconst URL_REGEX = /https?:\\/\\/[^\\s<>\"{}|\\\\^`\\[\\]]+/gi;\n\n// Patterns to ignore (timestamps, emails, social handles)\nconst TIMESTAMP_REGEX = /^\\d{1,2}:\\d{2}(:\\d{2})?$/;\nconst EMAIL_REGEX = /^mailto:|@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$/;\n\n// Amazon URL patterns\nconst AMAZON_DOMAINS = [\n  \"amazon.com\",\n  \"amazon.co.uk\",\n  \"amazon.ca\",\n  \"amazon.de\",\n  \"amazon.fr\",\n  \"amazon.es\",\n  \"amazon.it\",\n  \"amazon.co.jp\",\n  \"amazon.com.au\",\n  \"amazon.in\",\n  \"amzn.to\",\n  \"amzn.com\",\n  \"a.co\",\n];\n\n// ASIN regex (Amazon Standard Identification Number)\nconst ASIN_REGEX = /\\/(?:dp|gp\\/product|ASIN)\\/([A-Z0-9]{10})/i;\nconst ASIN_FROM_URL_REGEX = /[?&](?:asin|ASIN)=([A-Z0-9]{10})/i;\n\n// Tracking params to remove for normalization\nconst TRACKING_PARAMS = [\n  \"utm_source\",\n  \"utm_medium\",\n  \"utm_campaign\",\n  \"utm_term\",\n  \"utm_content\",\n  \"ref\",\n  \"ref_\",\n  \"linkCode\",\n  \"linkId\",\n  \"pd_rd_i\",\n  \"pd_rd_r\",\n  \"pd_rd_w\",\n  \"pd_rd_wg\",\n  \"pf_rd_i\",\n  \"pf_rd_m\",\n  \"pf_rd_p\",\n  \"pf_rd_r\",\n  \"pf_rd_s\",\n  \"pf_rd_t\",\n  \"psc\",\n  \"smid\",\n  \"spLa\",\n  \"sr\",\n  \"th\",\n  \"fbclid\",\n  \"gclid\",\n  \"dclid\",\n];\n\n/**\n * Checks if a URL is from Amazon\n */\nfunction isAmazonUrl(url: string): boolean {\n  try {\n    const urlObj = new URL(url);\n    const hostname = urlObj.hostname.toLowerCase();\n    return AMAZON_DOMAINS.some(domain =>\n      hostname === domain || hostname.endsWith(`.${domain}`)\n    );\n  } catch {\n    return false;\n  }\n}\n\n/**\n * Extracts ASIN from an Amazon URL\n */\nfunction extractAsin(url: string): string | undefined {\n  // Try to extract from path\n  const pathMatch = url.match(ASIN_REGEX);\n  if (pathMatch) return pathMatch[1];\n\n  // Try to extract from query params\n  const queryMatch = url.match(ASIN_FROM_URL_REGEX);\n  if (queryMatch) return queryMatch[1];\n\n  return undefined;\n}\n\n/**\n * Normalizes a URL by removing tracking parameters\n */\nfunction normalizeUrl(url: string): string {\n  try {\n    const urlObj = new URL(url);\n\n    // Remove tracking params\n    TRACKING_PARAMS.forEach(param => {\n      urlObj.searchParams.delete(param);\n    });\n\n    // Clean up hash if it looks like tracking\n    if (urlObj.hash && urlObj.hash.includes(\"ref=\")) {\n      urlObj.hash = \"\";\n    }\n\n    return urlObj.toString();\n  } catch {\n    return url;\n  }\n}\n\n/**\n * Checks if a string looks like a timestamp (not a URL)\n */\nfunction isTimestamp(text: string): boolean {\n  return TIMESTAMP_REGEX.test(text);\n}\n\n/**\n * Checks if a URL should be ignored (email, social handle, etc.)\n */\nfunction shouldIgnore(url: string): boolean {\n  return EMAIL_REGEX.test(url);\n}\n\n/**\n * Extracts and parses all URLs from a video description\n * @param description - The video description text\n * @returns Array of parsed links with merchant info\n */\nexport function extractLinksFromDescription(description: string): ParsedLink[] {\n  if (!description) return [];\n\n  // Find all URLs\n  const matches = description.match(URL_REGEX) || [];\n\n  // Process and deduplicate\n  const seenUrls = new Set<string>();\n  const links: ParsedLink[] = [];\n\n  for (const rawUrl of matches) {\n    // Clean up URL (remove trailing punctuation)\n    let url = rawUrl.replace(/[.,;:!?)]+$/, \"\");\n\n    // Skip timestamps and emails\n    if (isTimestamp(url) || shouldIgnore(url)) continue;\n\n    // Normalize the URL\n    const normalizedUrl = normalizeUrl(url);\n\n    // Skip duplicates\n    if (seenUrls.has(normalizedUrl)) continue;\n    seenUrls.add(normalizedUrl);\n\n    // Determine merchant and extract ASIN if Amazon\n    const isAmazon = isAmazonUrl(normalizedUrl);\n    const asin = isAmazon ? extractAsin(normalizedUrl) : undefined;\n\n    links.push({\n      url: normalizedUrl,\n      merchant: isAmazon ? \"amazon\" : \"other\",\n      asin,\n    });\n  }\n\n  return links;\n}\n\n/**\n * Filters links to only include affiliate links (currently Amazon only)\n */\nexport function filterAffiliateLinks(links: ParsedLink[]): ParsedLink[] {\n  return links.filter(link => link.merchant === \"amazon\");\n}\n\n/**\n * Gets statistics about extracted links\n */\nexport function getLinkStats(links: ParsedLink[]): {\n  total: number;\n  amazon: number;\n  other: number;\n  withAsin: number;\n} {\n  return {\n    total: links.length,\n    amazon: links.filter(l => l.merchant === \"amazon\").length,\n    other: links.filter(l => l.merchant === \"other\").length,\n    withAsin: links.filter(l => l.asin).length,\n  };\n}\n","import { LinkStatus } from \"@prisma/client\";\n\nexport interface LinkCheckResult {\n  status: LinkStatus;\n  httpStatus: number | null;\n  finalUrl: string | null;\n  availabilityStatus: string | null;\n  notes: string | null;\n}\n\n// Amazon out-of-stock indicators\nconst AMAZON_OOS_INDICATORS = [\n  \"Currently unavailable\",\n  \"Out of stock\",\n  \"We don't know when or if this item will be back\",\n  \"This item is not available\",\n  \"We don't know when or if this item will be back in stock\",\n  \"Available from these sellers\",\n  \"Sign up to be notified when this item becomes available\",\n];\n\n// Error page indicators\nconst ERROR_PAGE_INDICATORS = [\n  \"Page not found\",\n  \"404\",\n  \"Product not found\",\n  \"This page doesn't exist\",\n  \"Sorry, we couldn't find that page\",\n  \"The page you requested could not be found\",\n];\n\nconst DEFAULT_TIMEOUT = 10000; // 10 seconds\nconst MAX_RETRIES = 2;\nconst RETRY_DELAY = 1000; // 1 second\n\n/**\n * Sleeps for a specified duration\n */\nfunction sleep(ms: number): Promise<void> {\n  return new Promise(resolve => setTimeout(resolve, ms));\n}\n\n/**\n * Checks if HTML content indicates Amazon out of stock\n */\nfunction checkAmazonOOS(html: string): boolean {\n  const lowerHtml = html.toLowerCase();\n  return AMAZON_OOS_INDICATORS.some(indicator =>\n    lowerHtml.includes(indicator.toLowerCase())\n  );\n}\n\n/**\n * Checks if HTML content indicates an error page\n */\nfunction isErrorPage(html: string): boolean {\n  const lowerHtml = html.toLowerCase();\n  return ERROR_PAGE_INDICATORS.some(indicator =>\n    lowerHtml.includes(indicator.toLowerCase())\n  );\n}\n\n/**\n * Fetches a URL with timeout support\n */\nasync function fetchWithTimeout(\n  url: string,\n  options: RequestInit = {},\n  timeout: number = DEFAULT_TIMEOUT\n): Promise<Response> {\n  const controller = new AbortController();\n  const timeoutId = setTimeout(() => controller.abort(), timeout);\n\n  try {\n    const response = await fetch(url, {\n      ...options,\n      signal: controller.signal,\n      redirect: \"follow\",\n      headers: {\n        \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36\",\n        \"Accept\": \"text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\",\n        \"Accept-Language\": \"en-US,en;q=0.5\",\n        ...options.headers,\n      },\n    });\n    return response;\n  } finally {\n    clearTimeout(timeoutId);\n  }\n}\n\n/**\n * Checks a single link's health status\n * @param url - The URL to check\n * @param isAmazon - Whether this is an Amazon link (for OOS detection)\n */\nexport async function checkLink(\n  url: string,\n  isAmazon: boolean = false\n): Promise<LinkCheckResult> {\n  let lastError: Error | null = null;\n\n  for (let attempt = 0; attempt <= MAX_RETRIES; attempt++) {\n    if (attempt > 0) {\n      // Exponential backoff\n      await sleep(RETRY_DELAY * Math.pow(2, attempt - 1));\n    }\n\n    try {\n      // First try HEAD request\n      let response: Response;\n      try {\n        response = await fetchWithTimeout(url, { method: \"HEAD\" });\n      } catch {\n        // Fallback to GET if HEAD fails\n        response = await fetchWithTimeout(url, { method: \"GET\" });\n      }\n\n      const httpStatus = response.status;\n      const finalUrl = response.url;\n\n      // 404 / 410 - Not found\n      if (httpStatus === 404 || httpStatus === 410) {\n        return {\n          status: \"NOT_FOUND\",\n          httpStatus,\n          finalUrl,\n          availabilityStatus: \"broken\",\n          notes: `HTTP ${httpStatus}`,\n        };\n      }\n\n      // Other error status codes\n      if (httpStatus >= 400) {\n        return {\n          status: \"NOT_FOUND\",\n          httpStatus,\n          finalUrl,\n          availabilityStatus: \"error\",\n          notes: `HTTP ${httpStatus}`,\n        };\n      }\n\n      // For Amazon links, check for out of stock in response body\n      if (isAmazon && httpStatus === 200) {\n        // Need to do a GET request to check the body\n        const getResponse = await fetchWithTimeout(url, { method: \"GET\" });\n        const html = await getResponse.text();\n\n        // Check for error page (redirected to error)\n        if (isErrorPage(html)) {\n          return {\n            status: \"NOT_FOUND\",\n            httpStatus,\n            finalUrl: getResponse.url,\n            availabilityStatus: \"error_page\",\n            notes: \"Redirected to error page\",\n          };\n        }\n\n        // Check for out of stock\n        if (checkAmazonOOS(html)) {\n          return {\n            status: \"OOS\",\n            httpStatus,\n            finalUrl: getResponse.url,\n            availabilityStatus: \"out_of_stock\",\n            notes: \"Product appears to be out of stock\",\n          };\n        }\n      }\n\n      // Check if redirected to an error page (non-Amazon)\n      if (httpStatus >= 200 && httpStatus < 300) {\n        // Only check body for potential error pages on suspicious URLs\n        if (finalUrl !== url) {\n          const getResponse = await fetchWithTimeout(url, { method: \"GET\" });\n          const html = await getResponse.text();\n          if (isErrorPage(html)) {\n            return {\n              status: \"NOT_FOUND\",\n              httpStatus,\n              finalUrl: getResponse.url,\n              availabilityStatus: \"error_page\",\n              notes: \"Redirected to error page\",\n            };\n          }\n        }\n\n        return {\n          status: \"OK\",\n          httpStatus,\n          finalUrl,\n          availabilityStatus: \"available\",\n          notes: null,\n        };\n      }\n\n      // Redirect status (3xx) - follow was enabled so this shouldn't happen\n      if (httpStatus >= 300 && httpStatus < 400) {\n        return {\n          status: \"REDIRECT\",\n          httpStatus,\n          finalUrl,\n          availabilityStatus: \"redirect\",\n          notes: `Redirected to ${finalUrl}`,\n        };\n      }\n\n      // Success\n      return {\n        status: \"OK\",\n        httpStatus,\n        finalUrl,\n        availabilityStatus: \"available\",\n        notes: null,\n      };\n    } catch (error) {\n      lastError = error instanceof Error ? error : new Error(String(error));\n\n      // If it's the last attempt, return unknown status\n      if (attempt === MAX_RETRIES) {\n        const isTimeout = lastError.name === \"AbortError\" || lastError.message.includes(\"timeout\");\n        return {\n          status: \"UNKNOWN\",\n          httpStatus: null,\n          finalUrl: null,\n          availabilityStatus: isTimeout ? \"timeout\" : \"error\",\n          notes: isTimeout ? \"Request timed out\" : `Error: ${lastError.message}`,\n        };\n      }\n    }\n  }\n\n  // Should not reach here, but just in case\n  return {\n    status: \"UNKNOWN\",\n    httpStatus: null,\n    finalUrl: null,\n    availabilityStatus: \"error\",\n    notes: lastError?.message || \"Unknown error\",\n  };\n}\n\n/**\n * Checks multiple links with rate limiting\n * @param urls - Array of URLs to check\n * @param isAmazonMap - Map of URL to whether it's an Amazon link\n * @param delayMs - Delay between checks in milliseconds\n */\nexport async function checkLinksWithRateLimit(\n  urls: string[],\n  isAmazonMap: Map<string, boolean>,\n  delayMs: number = 500\n): Promise<Map<string, LinkCheckResult>> {\n  const results = new Map<string, LinkCheckResult>();\n\n  for (const url of urls) {\n    const isAmazon = isAmazonMap.get(url) || false;\n    const result = await checkLink(url, isAmazon);\n    results.set(url, result);\n\n    // Rate limiting\n    if (urls.indexOf(url) < urls.length - 1) {\n      await sleep(delayMs);\n    }\n  }\n\n  return results;\n}\n","import { prisma } from \"./db\";\nimport { extractLinksFromDescription, filterAffiliateLinks } from \"./link-parser\";\nimport { checkLink, LinkCheckResult } from \"./link-checker\";\n\nconst RATE_LIMIT_DELAY = 500; // 500ms between checks\n\n/**\n * Extracts and stores affiliate links from a video's description\n */\nexport async function extractAndStoreLinks(videoId: string): Promise<number> {\n  const video = await prisma.video.findUnique({\n    where: { id: videoId },\n    select: { description: true },\n  });\n\n  if (!video?.description) return 0;\n\n  // Extract links from description\n  const allLinks = extractLinksFromDescription(video.description);\n  const affiliateLinks = filterAffiliateLinks(allLinks);\n\n  // Store links (upsert to avoid duplicates)\n  let stored = 0;\n  for (const link of affiliateLinks) {\n    await prisma.affiliateLink.upsert({\n      where: {\n        id: `${videoId}_${link.url.slice(0, 100)}`, // Use composite key approximation\n      },\n      create: {\n        videoId,\n        originalUrl: link.url,\n        merchant: link.merchant,\n      },\n      update: {\n        merchant: link.merchant,\n      },\n    });\n    stored++;\n  }\n\n  return stored;\n}\n\n/**\n * Extracts links from all videos for a user\n */\nexport async function extractLinksForUser(userId: string): Promise<{ videos: number; links: number }> {\n  const videos = await prisma.video.findMany({\n    where: { userId },\n    select: { id: true, description: true },\n  });\n\n  let totalLinks = 0;\n\n  for (const video of videos) {\n    if (!video.description) continue;\n\n    const allLinks = extractLinksFromDescription(video.description);\n    const affiliateLinks = filterAffiliateLinks(allLinks);\n\n    for (const link of affiliateLinks) {\n      // Check if link already exists for this video\n      const existing = await prisma.affiliateLink.findFirst({\n        where: {\n          videoId: video.id,\n          originalUrl: link.url,\n        },\n      });\n\n      if (!existing) {\n        await prisma.affiliateLink.create({\n          data: {\n            videoId: video.id,\n            originalUrl: link.url,\n            merchant: link.merchant,\n          },\n        });\n        totalLinks++;\n      }\n    }\n  }\n\n  return { videos: videos.length, links: totalLinks };\n}\n\n/**\n * Checks a single link and stores the result\n */\nexport async function checkAndStoreLinkStatus(linkId: string): Promise<LinkCheckResult> {\n  const link = await prisma.affiliateLink.findUnique({\n    where: { id: linkId },\n    select: { originalUrl: true, merchant: true },\n  });\n\n  if (!link) {\n    throw new Error(`Link not found: ${linkId}`);\n  }\n\n  const isAmazon = link.merchant === \"amazon\";\n  const result = await checkLink(link.originalUrl, isAmazon);\n\n  // Update link status\n  await prisma.affiliateLink.update({\n    where: { id: linkId },\n    data: {\n      status: result.status,\n      lastCheckedAt: new Date(),\n    },\n  });\n\n  // Store scan result\n  await prisma.scanResult.create({\n    data: {\n      affiliateLinkId: linkId,\n      httpStatus: result.httpStatus,\n      availabilityStatus: result.availabilityStatus,\n      notes: result.notes,\n    },\n  });\n\n  return result;\n}\n\n/**\n * Scans all unchecked or stale links for a user\n * @param userId - User ID\n * @param staleThresholdDays - Links older than this many days are considered stale\n */\nexport async function scanUserLinks(\n  userId: string,\n  staleThresholdDays: number = 7\n): Promise<{ checked: number; issues: number }> {\n  const staleDate = new Date();\n  staleDate.setDate(staleDate.getDate() - staleThresholdDays);\n\n  // Get links that need checking\n  const links = await prisma.affiliateLink.findMany({\n    where: {\n      video: { userId },\n      OR: [\n        { lastCheckedAt: null },\n        { lastCheckedAt: { lt: staleDate } },\n      ],\n    },\n    select: {\n      id: true,\n      originalUrl: true,\n      merchant: true,\n    },\n    take: 100, // Limit per scan to avoid timeouts\n  });\n\n  let checked = 0;\n  let issues = 0;\n\n  for (const link of links) {\n    try {\n      const isAmazon = link.merchant === \"amazon\";\n      const result = await checkLink(link.originalUrl, isAmazon);\n\n      // Update link status\n      await prisma.affiliateLink.update({\n        where: { id: link.id },\n        data: {\n          status: result.status,\n          lastCheckedAt: new Date(),\n        },\n      });\n\n      // Store scan result\n      await prisma.scanResult.create({\n        data: {\n          affiliateLinkId: link.id,\n          httpStatus: result.httpStatus,\n          availabilityStatus: result.availabilityStatus,\n          notes: result.notes,\n        },\n      });\n\n      checked++;\n      if (result.status === \"NOT_FOUND\" || result.status === \"OOS\") {\n        issues++;\n      }\n\n      // Rate limiting\n      await new Promise(resolve => setTimeout(resolve, RATE_LIMIT_DELAY));\n    } catch (error) {\n      console.error(`Error checking link ${link.id}:`, error);\n    }\n  }\n\n  return { checked, issues };\n}\n\n/**\n * Gets scan statistics for a user\n */\nexport async function getScanStats(userId: string): Promise<{\n  totalLinks: number;\n  checkedLinks: number;\n  okLinks: number;\n  brokenLinks: number;\n  oosLinks: number;\n  unknownLinks: number;\n}> {\n  const links = await prisma.affiliateLink.findMany({\n    where: { video: { userId } },\n    select: { status: true, lastCheckedAt: true },\n  });\n\n  return {\n    totalLinks: links.length,\n    checkedLinks: links.filter(l => l.lastCheckedAt).length,\n    okLinks: links.filter(l => l.status === \"OK\").length,\n    brokenLinks: links.filter(l => l.status === \"NOT_FOUND\").length,\n    oosLinks: links.filter(l => l.status === \"OOS\").length,\n    unknownLinks: links.filter(l => l.status === \"UNKNOWN\").length,\n  };\n}\n\n/**\n * Full sync and scan for a user\n * 1. Extract links from all video descriptions\n * 2. Check all unchecked/stale links\n */\nexport async function fullSyncAndScan(userId: string): Promise<{\n  extractedLinks: number;\n  checkedLinks: number;\n  issues: number;\n}> {\n  // Step 1: Extract links\n  const { links: extractedLinks } = await extractLinksForUser(userId);\n\n  // Step 2: Scan links\n  const { checked: checkedLinks, issues } = await scanUserLinks(userId);\n\n  return {\n    extractedLinks,\n    checkedLinks,\n    issues,\n  };\n}\n","/**\n * Revenue estimation settings\n */\nexport interface RevenueSettings {\n  ctrPercent: number;      // Click-through rate (default: 2%)\n  conversionPercent: number; // Conversion rate (default: 3%)\n  avgOrderValue: number;   // Average order value in USD (default: $45)\n}\n\n/**\n * Default revenue estimation settings\n */\nexport const DEFAULT_SETTINGS: RevenueSettings = {\n  ctrPercent: 2.0,\n  conversionPercent: 3.0,\n  avgOrderValue: 45.0,\n};\n\n/**\n * Calculates estimated revenue loss for a broken/OOS link\n *\n * Formula: Video Views × CTR × Conversion Rate × AOV\n *\n * @param viewCount - Number of video views\n * @param settings - User's revenue estimation settings\n * @returns Estimated revenue loss in USD\n */\nexport function calculateEstimatedLoss(\n  viewCount: number,\n  settings: RevenueSettings = DEFAULT_SETTINGS\n): number {\n  const { ctrPercent, conversionPercent, avgOrderValue } = settings;\n\n  // Convert percentages to decimals\n  const ctr = ctrPercent / 100;\n  const conversionRate = conversionPercent / 100;\n\n  // Calculate estimated loss\n  // Views × CTR = estimated clicks\n  // Clicks × Conversion Rate = estimated purchases\n  // Purchases × AOV = estimated revenue\n  const estimatedLoss = viewCount * ctr * conversionRate * avgOrderValue;\n\n  // Round to 2 decimal places\n  return Math.round(estimatedLoss * 100) / 100;\n}\n\n/**\n * Calculates the total estimated loss across multiple links\n */\nexport function calculateTotalLoss(\n  links: Array<{ viewCount: number }>,\n  settings: RevenueSettings = DEFAULT_SETTINGS\n): number {\n  const total = links.reduce(\n    (sum, link) => sum + calculateEstimatedLoss(link.viewCount, settings),\n    0\n  );\n  return Math.round(total * 100) / 100;\n}\n\n/**\n * Formats a monetary value for display\n */\nexport function formatCurrency(amount: number): string {\n  return new Intl.NumberFormat(\"en-US\", {\n    style: \"currency\",\n    currency: \"USD\",\n    minimumFractionDigits: 0,\n    maximumFractionDigits: 0,\n  }).format(amount);\n}\n\n/**\n * Formats a large number for display (e.g., 1.2K, 1.5M)\n */\nexport function formatNumber(num: number): string {\n  if (num >= 1000000) {\n    return (num / 1000000).toFixed(1) + \"M\";\n  }\n  if (num >= 1000) {\n    return (num / 1000).toFixed(1) + \"K\";\n  }\n  return num.toString();\n}\n\n/**\n * Gets risk level based on estimated loss\n */\nexport function getRiskLevel(estimatedLoss: number): \"low\" | \"medium\" | \"high\" | \"critical\" {\n  if (estimatedLoss >= 1000) return \"critical\";\n  if (estimatedLoss >= 500) return \"high\";\n  if (estimatedLoss >= 100) return \"medium\";\n  return \"low\";\n}\n\n/**\n * Validates revenue settings\n */\nexport function validateSettings(settings: Partial<RevenueSettings>): {\n  valid: boolean;\n  errors: string[];\n} {\n  const errors: string[] = [];\n\n  if (settings.ctrPercent !== undefined) {\n    if (settings.ctrPercent < 0 || settings.ctrPercent > 100) {\n      errors.push(\"CTR must be between 0 and 100%\");\n    }\n  }\n\n  if (settings.conversionPercent !== undefined) {\n    if (settings.conversionPercent < 0 || settings.conversionPercent > 100) {\n      errors.push(\"Conversion rate must be between 0 and 100%\");\n    }\n  }\n\n  if (settings.avgOrderValue !== undefined) {\n    if (settings.avgOrderValue < 0) {\n      errors.push(\"Average order value must be positive\");\n    }\n    if (settings.avgOrderValue > 10000) {\n      errors.push(\"Average order value seems too high\");\n    }\n  }\n\n  return {\n    valid: errors.length === 0,\n    errors,\n  };\n}\n"],"names":[],"mappings":"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"}